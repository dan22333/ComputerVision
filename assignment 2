
import java.awt.*;
import java.awt.event.*;
import java.awt.image.*;
import java.io.*;
import javax.imageio.*;
import javax.swing.*;

/**
 * This class demonstrates how to load an Image from an external file
 */
public class LoadImageApp extends Component {
          
    BufferedImage img;

    public void paint(Graphics g) {
        g.drawImage(img, 0, 0, null);
    }

    public LoadImageApp(String InputPath) {
       try {
           img = ImageIO.read(new File(InputPath));
       } catch (IOException e) {
    	   System.err.println("Can't open this link"+ InputPath);
    	   return;
       }

    }
    
    
    // ************* TODO - Bonus ************************************************
    public static String chooseDirection(BufferedImage img){ // chose the direction of the seam
    	return "Horizontal";
    }
    
    
    //computing the entropy
    public static double[][] EntropyComputation(BufferedImage img){
    
    	int width = img.getWidth();
    	int height = img.getHeight();
    	double[][] entropyTable = new double[width][height];
    	
    	//*********** TODO *******************
    	
    	return entropyTable;
    }
    
    //computing the energy
    public static double[][] EnergyComputation(BufferedImage img){
    	
    	int width = img.getWidth();
    	int height = img.getHeight();
    	double[][] energyTable = new double[width][height];//the output
    	int current_pixel, temp,current_red,current_blue,current_green;
    	//define the array that will store the info about the neighbors
    	int[][] val;
        val = new int[8][4];
        //loop through all the pixels in the picture and compute it's energy
    	for (int x = 0; x < width; x++) {
    		for (int y = 0; y < height; y++) {
    			current_pixel = img.getRGB(x,y); // get RGB of current pixel
    			current_red = (current_pixel & 0x00ff0000) >> 16;
    			current_green = (current_pixel & 0x0000ff00) >> 8;
    			current_blue = (current_pixel & 0x000000ff);
    			//Deal with the edges:
    			if (y == 0) { //the first column
    				temp = img.getRGB(x, y+1) ;
    				val[0][0] = (temp & 0x00ff0000) >> 16; //red color in temp
    				val[0][1] = (temp & 0x0000ff00) >> 8;//green color in temp
    				val[0][2] = (temp & 0x000000ff);//bue color in temp
    				val[0][3] = (Math.abs(current_red-val[0][0])+Math.abs(current_green-val[0][1])+Math.abs(current_blue-val[0][2]))/3;
    				if(x == 0) { // the up-left corner
    					temp = img.getRGB(x+1,y+1);
    					val[1][0] = (temp & 0x00ff0000) >> 16;
        				val[1][1] = (temp & 0x0000ff00) >> 8;;
        				val[1][2] = (temp & 0x000000ff);
        				val[1][3] = (Math.abs(current_red-val[1][0])+Math.abs(current_green-val[1][1])+Math.abs(current_blue-val[1][2]))/3;

    					temp = img.getRGB(x+1,y);
    					val[2][0] = (temp & 0x00ff0000) >> 16;
        				val[2][1] = (temp & 0x0000ff00) >> 8;;
        				val[2][2] = (temp & 0x000000ff);
        				val[2][3] = (Math.abs(current_red-val[2][0])+Math.abs(current_green-val[2][1])+Math.abs(current_blue-val[2][2]))/3;

    					energyTable[x][y] = (val[0][3]+val[1][3]+val[2][3])/3;
    				}
    				else if (x == width - 1){ // the down-left corner
    					temp = img.getRGB(x-1,y+1);
    					val[1][0] = (temp & 0x00ff0000) >> 16;
        				val[1][1] = (temp & 0x0000ff00) >> 8;;
        				val[1][2] = (temp & 0x000000ff);
        				val[1][3] = (Math.abs(current_red-val[1][0])+Math.abs(current_green-val[1][1])+Math.abs(current_blue-val[1][2]))/3;
    					
    					temp = img.getRGB(x-1,y);
    					val[2][0] = (temp & 0x00ff0000) >> 16;
        				val[2][1] = (temp & 0x0000ff00) >> 8;;
        				val[2][2] = (temp & 0x000000ff);
        				val[2][3] = (Math.abs(current_red-val[2][0])+Math.abs(current_green-val[2][1])+Math.abs(current_blue-val[2][2]))/3;
    					energyTable[x][y] = (val[0][3]+val[1][3]+val[2][3])/3;
    				}
    				else{ // the rest of the first column
    					temp = img.getRGB(x-1,y);
    					val[1][0] = (temp & 0x00ff0000) >> 16;
        				val[1][1] = (temp & 0x0000ff00) >> 8;;
        				val[1][2] = (temp & 0x000000ff);
        				val[1][3] = (Math.abs(current_red-val[1][0])+Math.abs(current_green-val[1][1])+Math.abs(current_blue-val[1][2]))/3;
    					
    					temp = img.getRGB(x-1,y+1);
    					val[2][0] = (temp & 0x00ff0000) >> 16;
        				val[2][1] = (temp & 0x0000ff00) >> 8;;
        				val[2][2] = (temp & 0x000000ff);
        				val[2][3] = (Math.abs(current_red-val[2][0])+Math.abs(current_green-val[2][1])+Math.abs(current_blue-val[2][2]))/3;
    					
        				temp = img.getRGB(x+1,y+1);
        				val[3][0] = (temp & 0x00ff0000) >> 16;
        				val[3][1] = (temp & 0x0000ff00) >> 8;;
        				val[3][2] = (temp & 0x000000ff);
        				val[3][3] = (Math.abs(current_red-val[3][0])+Math.abs(current_green-val[3][1])+Math.abs(current_blue-val[3][2]))/3;
    					
        				temp = img.getRGB(x+1,y);
        				val[4][0] = (temp & 0x00ff0000) >> 16;
        				val[4][1] = (temp & 0x0000ff00) >> 8;;
        				val[4][2] = (temp & 0x000000ff);
        				val[4][3] = (Math.abs(current_red-val[4][0])+Math.abs(current_green-val[4][1])+Math.abs(current_blue-val[4][2]))/3;
    					
        				energyTable[x][y] = (val[0][3]+val[1][3]+val[2][3]+val[3][3]+val[4][3])/5;
    				}
    			}
    			else if( y == height) { // the last column
    				temp = img.getRGB(x, y-1);
    				val[0][0] = (temp & 0x00ff0000) >> 16; //red color in temp
    				val[0][1] = (temp & 0x0000ff00) >> 8;//green color in temp
    				val[0][2] = (temp & 0x000000ff);//bue color in temp
    				val[0][3] = (Math.abs(current_red-val[0][0])+Math.abs(current_green-val[0][1])+Math.abs(current_blue-val[0][2]))/3;
    				if(x == 0) { // the up-right corner
    					temp = img.getRGB(x+1,y-1);
    					val[1][0] = (temp & 0x00ff0000) >> 16;
        				val[1][1] = (temp & 0x0000ff00) >> 8;;
        				val[1][2] = (temp & 0x000000ff);
        				val[1][3] = (Math.abs(current_red-val[1][0])+Math.abs(current_green-val[1][1])+Math.abs(current_blue-val[1][2]))/3;
    					
    					temp = img.getRGB(x+1,y);
    					val[2][0] = (temp & 0x00ff0000) >> 16;
        				val[2][1] = (temp & 0x0000ff00) >> 8;;
        				val[2][2] = (temp & 0x000000ff);
        				val[2][3] = (Math.abs(current_red-val[2][0])+Math.abs(current_green-val[2][1])+Math.abs(current_blue-val[2][2]))/3;
    					
    					energyTable[x][y] = (val[0][3]+val[1][3]+val[2][3])/3;
    				}
    				else if (x == width - 1){ // the down-right corner
    					temp = img.getRGB(x-1,y-1);
    					val[1][0] = (temp & 0x00ff0000) >> 16;
        				val[1][1] = (temp & 0x0000ff00) >> 8;;
        				val[1][2] = (temp & 0x000000ff);
        				val[1][3] = (Math.abs(current_red-val[1][0])+Math.abs(current_green-val[1][1])+Math.abs(current_blue-val[1][2]))/3;
    					
    					temp = img.getRGB(x-1,y);
    					val[2][0] = (temp & 0x00ff0000) >> 16;
        				val[2][1] = (temp & 0x0000ff00) >> 8;;
        				val[2][2] = (temp & 0x000000ff);
        				val[2][3] = (Math.abs(current_red-val[2][0])+Math.abs(current_green-val[2][1])+Math.abs(current_blue-val[2][2]))/3;
    					
        				energyTable[x][y] = (val[0][3]+val[1][3]+val[2][3])/3;
    				}
    				else{ // the rest of the last column
    					temp = img.getRGB(x-1,y);
    					val[1][0] = (temp & 0x00ff0000) >> 16;
        				val[1][1] = (temp & 0x0000ff00) >> 8;;
        				val[1][2] = (temp & 0x000000ff);
        				val[1][3] = (Math.abs(current_red-val[1][0])+Math.abs(current_green-val[1][1])+Math.abs(current_blue-val[1][2]))/3;
    					
    					temp = img.getRGB(x-1,y-1);
    					val[2][0] = (temp & 0x00ff0000) >> 16;
        				val[2][1] = (temp & 0x0000ff00) >> 8;;
        				val[2][2] = (temp & 0x000000ff);
        				val[2][3] = (Math.abs(current_red-val[2][0])+Math.abs(current_green-val[2][1])+Math.abs(current_blue-val[2][2]))/3;
    					
    					temp = img.getRGB(x+1,y-1);
    					val[3][0] = (temp & 0x00ff0000) >> 16;
        				val[3][1] = (temp & 0x0000ff00) >> 8;;
        				val[3][2] = (temp & 0x000000ff);
        				val[3][3] = (Math.abs(current_red-val[3][0])+Math.abs(current_green-val[3][1])+Math.abs(current_blue-val[3][2]))/3;
    					
    					temp = img.getRGB(x+1,y);
    					val[4][0] = (temp & 0x00ff0000) >> 16;
        				val[4][1] = (temp & 0x0000ff00) >> 8;;
        				val[4][2] = (temp & 0x000000ff);
        				val[4][3] = (Math.abs(current_red-val[4][0])+Math.abs(current_green-val[4][1])+Math.abs(current_blue-val[4][2]))/3;
    					
        				energyTable[x][y] = (val[0][3]+val[1][3]+val[2][3]+val[3][3]+val[4][3])/5;    				
        				}
    			}
    			//this pixel is not on the edge:
    			temp = img.getRGB(x-1, y-1);
    			val[0][0] = (temp & 0x00ff0000) >> 16; //red color in temp
				val[0][1] = (temp & 0x0000ff00) >> 8;//green color in temp
				val[0][2] = (temp & 0x000000ff);//bue color in temp
				val[0][3] = (Math.abs(current_red-val[0][0])+Math.abs(current_green-val[0][1])+Math.abs(current_blue-val[0][2]))/3;
				
    			temp = img.getRGB(x-1, y);
    			val[1][0] = (temp & 0x00ff0000) >> 16;
				val[1][1] = (temp & 0x0000ff00) >> 8;;
				val[1][2] = (temp & 0x000000ff);
				val[1][3] = (Math.abs(current_red-val[1][0])+Math.abs(current_green-val[1][1])+Math.abs(current_blue-val[1][2]))/3;
				
    			temp = img.getRGB(x-1, y+1);
    			val[2][0] = (temp & 0x00ff0000) >> 16;
				val[2][1] = (temp & 0x0000ff00) >> 8;;
				val[2][2] = (temp & 0x000000ff);
				val[2][3] = (Math.abs(current_red-val[2][0])+Math.abs(current_green-val[2][1])+Math.abs(current_blue-val[2][2]))/3;
				
    			temp = img.getRGB(x, y + 1);
    			val[3][0] = (temp & 0x00ff0000) >> 16;
				val[3][1] = (temp & 0x0000ff00) >> 8;;
				val[3][2] = (temp & 0x000000ff);
				val[3][3] = (Math.abs(current_red-val[3][0])+Math.abs(current_green-val[3][1])+Math.abs(current_blue-val[3][2]))/3;
				
    			temp = img.getRGB(x-1, y+1);
    			val[4][0] = (temp & 0x00ff0000) >> 16;
				val[4][1] = (temp & 0x0000ff00) >> 8;;
				val[4][2] = (temp & 0x000000ff);
				val[4][3] = (Math.abs(current_red-val[4][0])+Math.abs(current_green-val[4][1])+Math.abs(current_blue-val[4][2]))/3;
    			
				temp = img.getRGB(x-1, y);
				val[5][0] = (temp & 0x00ff0000) >> 16; //red color in temp
				val[5][1] = (temp & 0x0000ff00) >> 8;//green color in temp
				val[5][2] = (temp & 0x000000ff);//bue color in temp
				val[5][3] = (Math.abs(current_red-val[5][0])+Math.abs(current_green-val[5][1])+Math.abs(current_blue-val[5][2]))/3;
				
    			temp = img.getRGB(x-1, y-1);
    			val[6][0] = (temp & 0x00ff0000) >> 16; //red color in temp
				val[6][1] = (temp & 0x0000ff00) >> 8;//green color in temp
				val[6][2] = (temp & 0x000000ff);//bue color in temp
				val[6][3] = (Math.abs(current_red-val[6][0])+Math.abs(current_green-val[6][1])+Math.abs(current_blue-val[6][2]))/3;
				
    			temp = img.getRGB(x, y-1);
    			val[7][0] = (temp & 0x00ff0000) >> 16; //red color in temp
				val[7][1] = (temp & 0x0000ff00) >> 8;//green color in temp
				val[7][2] = (temp & 0x000000ff);//bue color in temp
				val[7][3] = (Math.abs(current_red-val[7][0])+Math.abs(current_green-val[7][1])+Math.abs(current_blue-val[7][2]))/3;
				
    			energyTable[x][y] = (val[0][3]+val[1][3]+val[2][3]+val[3][3]+val[4][3]+val[5][3]+val[6][3]+val[7][3])/8;
    		}
    	}
    	
    	
    	return energyTable;
    }

    //************TODO*********************
    //computing the vertical seam (the simple version) with dynamic programming
    private static int[][] SeamFinderSimple (double[][] energyTable){
    	int[][] seam;
    	int width = energyTable.length;
    	int height = energyTable[0].length;
    	
    	double[][] dynamic = new double[width][height]; // temmporal table for dynamic programming
    	int[][] nacktracker = new int[width][height];
    	double min;
    	seam = new int[energyTable[0].length][2];//The seam that we will return
    	//Loop the energy table to find the lowest energy path
    	// after computing path, backtrack the minimum

    	return seam;
    }
  
    
    //************TODO*********************
    //computing the vertical seam (the general version) with dynamic programming
    private static int[][] SeamFinderGeneral (double[][] energyTable){
    	int width = energyTable.length;
    	int height = energyTable[0].length;
    	
    	double[][] dynamic = new double[width][height]; // temmporal table for dynamic programming
    	int[][] nacktracker = new int[width][height];
    	double min;
    	int[][] seam = new int[energyTable[0].length][2];//The seam that we will return
    	//Loop the energy table to find the lowest energy path
    	// after computing path, find the min
    	//backtrack the minimum
    	
    	return seam;
    }
    
    private static int[][] SeamFinder (double[][] energyTable, String direction, String type) {
    	//direction is either horizontal or vertical
    	//type is simple or general
    	
    	int[][] seam = new int[energyTable[0].length][2];//The seam that we will return
    	if (direction.equals("vertical")) {
    		if(type.equals("simple")) {
    			seam = SeamFinderSimple(energyTable);	
    		}
    		else if (type.equals("general")) {
    			seam = SeamFinderGeneral(energyTable);
    		}
    		else {
    			System.out.println("the type in SeamFinder is incorrect");
    		}	
    	}
    	else if (direction.equals("horizontal")) {
    		//transposing the picture (it's energyTable)
    		double[][] transposedTable = new double[energyTable[0].length][energyTable.length]; 
    		
    		for (int i=0; i< energyTable[0].length; i++ ) {
    			for (int j=0; j<energyTable.length; j++) {
    				transposedTable[i][j] = energyTable[j][i];
    			}
    		}
    		energyTable = transposedTable;
    		
    		if(type.equals("simple")) {
    			seam = SeamFinderSimple(energyTable);	
    		}
    		else if (type.equals("general")) {
    			seam = SeamFinderGeneral(energyTable);
    		}
    		else {
    			System.out.println("the type in SeamFinder is incorrect");
    			System.exit (1);
    		}	
    	}
    	else {
    		System.out.println("Incorrect direction in SeamFinder. must be vertical or horizontal");
    		System.exit (1);
    	}
    	return seam;
    }
    
    private static BufferedImage seamRemove (BufferedImage img, int[][] seam, String direction) {
    	BufferedImage newImage;
    	int width = img.getWidth();
    	int height = img.getHeight();
    	if (direction.equals("vertical")) {
    		newImage = new BufferedImage (width -1, height, BufferedImage.TYPE_INT_ARGB);
    	}
    	else if (direction.equals("horizontal")) {
    		newImage = new BufferedImage (width, height-1, BufferedImage.TYPE_INT_ARGB);
    	} 
    	//Loop on every pixel in the picture and copies them to the new picture except from the seam
    	//*********** TODO ******************
    	return newImage;
    }
    
    
    public Dimension getPreferredSize() {
        if (img == null) {
             return new Dimension(100,100);
        } else {
           return new Dimension(img.getWidth(null), img.getHeight(null));
       }
    }

    public static void main(String[] args) {

    	//The inputs of the program:
    	String InputPath = null; //Full path to the input image
    	int NumCol = 0; //Number of columns of the resized output image
    	int NumRow = 0; //Number of rows of the resized output image
    	int energy = 0; //An argument with three possible values, where '0' = regular energy without entropy term,
    					//'1' = regular energy with entropy term and '2' = forward energy
    	String OutputPath = null; //Full path to the output image

    	if (args.length > 0) {
    	    try {
    	        NumCol = Integer.parseInt(args[1]);
    	        NumRow = Integer.parseInt(args[2]);
    	        energy = Integer.parseInt(args[3]);
    	    } catch (NumberFormatException e) {
    	        System.err.println("Arguments must be an integeres.");
    	        System.exit(1);
    	    }
    	    InputPath = args[0];
    	    OutputPath = args[4];
    	}
    	
    	JFrame f = new JFrame("Load Image Sample");
            
        f.addWindowListener(new WindowAdapter(){
                public void windowClosing(WindowEvent e) {
                    System.exit(0);
                }
            });

        f.add(new LoadImageApp(InputPath));
        f.pack();
        f.setVisible(true);
    }
}
